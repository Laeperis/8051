C51 COMPILER V9.60.7.0   MAIN                                                              07/09/2025 23:42:15 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: E:\Keil_V5\C51\BIN\C51.EXE test\test\main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Lis
                    -tings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <reg51.h>
   2          #include <stdio.h>
   3          #include "lcd1602.h"
   4          #include "dht11.h"
   5          
   6          sbit KEY = P3^2; // 启动/停止按键
   7          
   8          bit collect_flag = 0; // 采集标志
   9          volatile char last_rx = 0;
  10          volatile bit rx_flag = 0;
  11          char debug[17]; // 全局变量
  12          
  13          volatile unsigned char current_channel = 0; // 0=DHT11, 1=555频率
  14          volatile bit freq_sample_flag = 0;
  15          volatile unsigned char t0_count = 0;
  16          volatile unsigned int freq_count = 0; // 中断计数值
  17          unsigned int freq_value = 0;        // 主循环读取值
  18          
  19          void UART_Init() {
  20   1          SCON = 0x50;      // 8位数据,可变波特率
  21   1          TMOD |= 0x20;     // 定时器1，8位自动重装
  22   1          TH1 = 0xFD;       // 9600波特率
  23   1          TL1 = 0xFD;
  24   1          TR1 = 1;
  25   1          ES = 1;
  26   1          EA = 1;
  27   1      }
  28          
  29          void Timer0_Init() {
  30   1          TMOD &= 0xF0;
  31   1          TMOD |= 0x01; // T0方式1
  32   1          TH0 = (65536 - 50000) / 256; // 50ms定时
  33   1          TL0 = (65536 - 50000) % 256;
  34   1          ET0 = 1;
  35   1          TR0 = 1;
  36   1      }
  37          
  38          void Timer1_Init() {
  39   1          TMOD &= 0x0F;
  40   1          TMOD |= 0x50; // T1方式1，计数器模式
  41   1          TH1 = 0;
  42   1          TL1 = 0;
  43   1          TR1 = 1;
  44   1      }
  45          
  46          void INT0_Init() {
  47   1          IT0 = 1; // 下降沿触发
  48   1          // EX0 = 1; // 不再默认使能INT0
  49   1      }
  50          
  51          void UART_SendStr(char *str) {
  52   1          while(*str) {
  53   2              SBUF = *str++;
  54   2              while(!TI);
C51 COMPILER V9.60.7.0   MAIN                                                              07/09/2025 23:42:15 PAGE 2   

  55   2              TI = 0;
  56   2          }
  57   1      }
  58          
  59          void UART_ISR() interrupt 4 {
  60   1          if(RI) {
  61   2              last_rx = SBUF;
  62   2              rx_flag = 1;
  63   2              RI = 0;
  64   2      
  65   2              // 1. Update state variables based on command
  66   2              if(last_rx == 'S') collect_flag = 1;
  67   2              if(last_rx == 'E') collect_flag = 0;
  68   2              if(last_rx == 'A') {
  69   3                  current_channel = 0;
  70   3                  LCD_ShowString(0,0,"                "); // 清空第一行
  71   3                  LCD_ShowString(1,0,"                "); // 清空第二行
  72   3              }
  73   2              if(last_rx == 'B') {
  74   3                  current_channel = 1;
  75   3                  LCD_ShowString(0,0,"                "); // 清空第一行
  76   3                  LCD_ShowString(1,0,"                "); // 清空第二行
  77   3              }
  78   2      
  79   2              // 2. Set hardware state based on current system state
  80   2              if(collect_flag && current_channel == 1) {
  81   3                  // Only enable interrupt if collecting AND in frequency mode
  82   3                  EX0 = 1;
  83   3              } else {
  84   3                  // In all other cases (stopped OR in temp mode), disable it.
  85   3                  EX0 = 0;
  86   3              }
  87   2          }
  88   1      }
  89          
  90          void Timer0_ISR() interrupt 1 {
  91   1          TH0 = (65536 - 50000) / 256;
  92   1          TL0 = (65536 - 50000) % 256;
  93   1          t0_count++;
  94   1          if (t0_count >= 2) { // 2*50ms=100ms
  95   2              t0_count = 0;
  96   2              freq_sample_flag = 1; // 产生100ms采样标志
  97   2          }
  98   1      }
  99          
 100          extern void Delay1000ms();
 101          sbit FREQ_IN = P3^2;
 102          
 103          void main() {
 104   1          static unsigned char last_mode = 0xFF; // 不可能的初值，保证首次切换
 105   1          unsigned char temp, humi;
 106   1          char buf[20];
 107   1          unsigned int count;
 108   1          unsigned int freq_value = 0;
 109   1          unsigned int pulse_count;
 110   1          unsigned long i;
 111   1          bit last_p32_state;
 112   1      
 113   1          UART_SendStr("[DEBUG] UART_Init\r\n");
 114   1          UART_Init();
 115   1          UART_SendStr("[DEBUG] LCD_Init\r\n");
 116   1          LCD_Init();
C51 COMPILER V9.60.7.0   MAIN                                                              07/09/2025 23:42:15 PAGE 3   

 117   1          UART_SendStr("[DEBUG] Timer0_Init\r\n");
 118   1          Timer0_Init();
 119   1          EA = 1; // 总中断使能
 120   1          EX0 = 0; // 默认关闭外部中断0
 121   1          UART_SendStr("[DEBUG] Init Done\r\n");
 122   1          LCD_ShowString(0,0,"WAIT CMD      ");
 123   1          while(1) {
 124   2              if(collect_flag) {
 125   3                  if(current_channel == 1) { // 555频率测量 (手动轮询)
 126   4                      if(freq_sample_flag) {
 127   5                          freq_sample_flag = 0;
 128   5                          pulse_count = 0;
 129   5                          last_p32_state = FREQ_IN;
 130   5                          // 在100ms内进行轮询检测
 131   5                          for(i=0; i<30000; i++) { // 这是一个粗略的延时
 132   6                              if(last_p32_state == 1 && FREQ_IN == 0) {
 133   7                                  pulse_count++;
 134   7                              }
 135   6                              last_p32_state = FREQ_IN;
 136   6                          }
 137   5                          freq_value = pulse_count * 10; // 100ms的计数值*10=1s的频率
 138   5                          LCD_ShowString(0,0,"FREQ:      Hz");
 139   5                          LCD_ShowNum(0,5,freq_value,5);
 140   5                          sprintf(buf, "FREQ:%u\r\n", freq_value);
 141   5                          UART_SendStr(buf);
 142   5                      }
 143   4                  } else if(current_channel == 0) { // DHT11温湿度
 144   4                      Delay1000ms(); // 每次读取之间必须有延时
 145   4                      EA = 0; // 关闭总中断
 146   4                      if(DHT11_Read(&temp, &humi) == 0) {
 147   5                          EA = 1; // 恢复总中断
 148   5                          UART_SendStr("[DEBUG] DHT11 OK\r\n");
 149   5                          LCD_ShowString(0,0,"Temp:    C");
 150   5                          LCD_ShowString(1,0,"Humi:    %");
 151   5                          LCD_ShowNum(0,6,temp,2);
 152   5                          LCD_ShowNum(1,6,humi,2);
 153   5                          sprintf(buf, "T:%u H:%u\r\n", (unsigned int)temp, (unsigned int)humi);
 154   5                          UART_SendStr(buf);
 155   5                      } else {
 156   5                          EA = 1; // 恢复总中断
 157   5                          UART_SendStr("[DEBUG] DHT11 FAIL\r\n");
 158   5                          LCD_ShowString(0,0,"Temp:    C");
 159   5                          LCD_ShowString(1,0,"Humi:    %");
 160   5                          LCD_ShowNum(0,6,99,2);
 161   5                          LCD_ShowNum(1,6,99,2);
 162   5                          UART_SendStr("DHT11 FAIL\r\n");
 163   5                      }
 164   4                  }
 165   3              } else {
 166   3                  LCD_ShowString(0,0,"WAIT CMD      ");
 167   3                  LCD_ShowString(1,0,"              ");
 168   3                  Delay1000ms();
 169   3              }
 170   2          }
 171   1      } 
*** WARNING C280 IN LINE 104 OF test\test\main.c: 'last_mode': unreferenced local variable
*** WARNING C280 IN LINE 107 OF test\test\main.c: 'count': unreferenced local variable


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    748    ----
   CONSTANT SIZE    =    239    ----
C51 COMPILER V9.60.7.0   MAIN                                                              07/09/2025 23:42:15 PAGE 4   

   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     25      35
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
