C51 COMPILER V9.59.0.0   MAIN                                                              07/12/2025 09:46:03 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: F:\Keil uvision5 C51v959(64bit)\C51\BIN\C51.EXE test\test\main.c BROWSE DEBUG OBJECTEXTEND PRINT(.\
                    -Listings\main.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <reg51.h>
   2          #include <stdio.h>
   3          #include "lcd1602.h"
   4          #include "dht11.h"
   5          #include <string.h>
   6          #include <stdlib.h>
   7          #include <intrins.h> // 修正 _nop_ 错误
   8          #define u8 unsigned char // 修正 u8 未定义
   9          
  10          void UART_SendStr(char *str); // 添加函数原型声明，防止编译器警告
  11          
  12          sbit KEY = P3^2; // 启动/停止按键
  13          
  14          bit collect_flag = 0; // 采集标志
  15          volatile char last_rx = 0;
  16          volatile bit rx_flag = 0;
  17          // char debug[17]; // 全局变量（删除，调试用局部变量）
  18          
  19          // 优化：用于接收上位机回发的数字，增加缓冲区大小以容纳校验和
  20          unsigned char xdata num_buf[24]; // 放到xdata区，增加大小以容纳校验和
  21          unsigned char num_idx = 0;
  22          
  23          volatile unsigned char current_channel = 0; // 0=DHT11, 1=555频率
  24          volatile bit freq_sample_flag = 0;
  25          volatile unsigned char t0_count = 0;
  26          
  27          // -- 频率测量所需的状态变量 --
  28          volatile unsigned int freq_count = 0; // 用于累加脉冲数量
  29          unsigned int freq_value = 0;        // 用于存放最终计算出的频率值
  30          static bit last_p32_state = 1;      // 用于检测P3.2引脚的下降沿
  31          
  32          // I2C/PCF8591相关定义
  33          sbit IIC_SDA = P1^1;
  34          sbit IIC_SCL = P1^0;
  35          #define PCF8591_WRITE_ADDR 0x90
  36          #define PCF8591_READ_ADDR  0x91
  37          //报警LED定义
  38          sbit LED1 = P1^2;
  39          sbit LED2 = P1^3;
  40          sbit LED3 = P1^4;
  41          
  42          void IIC_Delay() { _nop_(); _nop_(); _nop_(); }
  43          void IIC_SendStart(void) {
  44   1          IIC_SDA=1; IIC_SCL=1; IIC_Delay();
  45   1          IIC_SDA=0; IIC_Delay();
  46   1          IIC_SCL=0;
  47   1      }
  48          void IIC_SendStop(void) {
  49   1          IIC_SCL=0; IIC_SDA=0; IIC_Delay();
  50   1          IIC_SCL=1; IIC_SDA=1; IIC_Delay();
  51   1      }
  52          u8 IIC_GetAck(void) {
  53   1          u8 i=0; IIC_SDA=1; IIC_SCL=1;
  54   1          while(IIC_SDA) { i++; if(i>250) { IIC_SCL=0; return 1; } }
C51 COMPILER V9.59.0.0   MAIN                                                              07/12/2025 09:46:03 PAGE 2   

  55   1          IIC_SCL=0; return 0;
  56   1      }
  57          void IIC_SendOneByte(u8 dat) {
  58   1          u8 j;
  59   1          for(j=0;j<8;j++) {
  60   2              IIC_SCL=0;
  61   2              IIC_SDA=(dat&0x80)?1:0;
  62   2              dat<<=1;
  63   2              IIC_SCL=1; IIC_Delay();
  64   2          }
  65   1          IIC_SCL=0;
  66   1      }
  67          void PCF8591_SetDAC_Data(u8 val) {
  68   1          IIC_SendStart();
  69   1          IIC_SendOneByte(PCF8591_WRITE_ADDR);
  70   1          IIC_GetAck();
  71   1          IIC_SendOneByte(0x40); // 控制字节：DAC使能
  72   1          IIC_GetAck();
  73   1          IIC_SendOneByte(val);
  74   1          IIC_GetAck();
  75   1          IIC_SendStop();
  76   1      }
  77          void Delay100ms() {
  78   1          unsigned char i, j;
  79   1          for(i=0;i<20;i++) {
  80   2              for(j=0;j<250;j++); // 1us*250*20=5ms*20=100ms
  81   2          }
  82   1      }
  83          
  84          // 解析并输出温湿度减半值到DAC
  85          void handle_half_value(const char* str) {
  86   1          int t = 0, h = 0;
  87   1          UART_SendStr("[DEBUG] RAW BUF: ");
  88   1          UART_SendStr(str);
  89   1          UART_SendStr("\r\n");
  90   1          sscanf(str, "%d %d", &t, &h);
  91   1          // 先输出温度
  92   1          PCF8591_SetDAC_Data((unsigned char)t);
  93   1          UART_SendStr("[DEBUG] DAC OUT TEMP: ");
  94   1          {
  95   2              char xdata buf[8]; // 放到xdata区
  96   2              unsigned int temp_val = (unsigned char)t;
  97   2              sprintf(buf, "%u\r\n", temp_val);
  98   2              UART_SendStr(buf);
  99   2          }
 100   1          Delay100ms();
 101   1          // 再输出湿度
 102   1          PCF8591_SetDAC_Data((unsigned char)h);
 103   1          UART_SendStr("[DEBUG] DAC OUT HUMI: ");
 104   1          {
 105   2              char xdata buf[8]; // 放到xdata区
 106   2              unsigned int humi_val = (unsigned char)h;
 107   2              sprintf(buf, "%u\r\n", humi_val);
 108   2              UART_SendStr(buf);
 109   2          }
 110   1          Delay100ms();
 111   1      }
 112          
 113          // 新增：解析并输出减半频率值到DAC
 114          void handle_half_freq(const char* str) {
 115   1          int f = 0;
 116   1          UART_SendStr("[DEBUG] RAW FREQ BUF: ");
C51 COMPILER V9.59.0.0   MAIN                                                              07/12/2025 09:46:03 PAGE 3   

 117   1          UART_SendStr(str);
 118   1          UART_SendStr("\r\n");
 119   1          sscanf(str, "%d", &f);
 120   1          PCF8591_SetDAC_Data((unsigned char)f);
 121   1          UART_SendStr("[DEBUG] DAC OUT FREQ: ");
 122   1          {
 123   2              char xdata buf[8];
 124   2              unsigned int freq_val = (unsigned char)f;
 125   2              sprintf(buf, "%u\r\n", freq_val);
 126   2              UART_SendStr(buf);
 127   2          }
 128   1          Delay100ms();
 129   1      }
 130          
 131          // 新增：校验和计算函数
 132          unsigned int calculate_checksum(char *str) {
 133   1          unsigned int checksum = 0;
 134   1          while(*str) {
 135   2              checksum += *str++;
 136   2          }
 137   1          return checksum;
 138   1      }
 139          
 140          void UART_Init() {
 141   1          SCON = 0x50;      // 8位数据,可变波特率
 142   1          TMOD |= 0x20;     // 定时器1，8位自动重装
 143   1          TH1 = 0xFD;       // 9600波特率
 144   1          TL1 = 0xFD;
 145   1          TR1 = 1;
 146   1          ES = 1;
 147   1          EA = 1;
 148   1      }
 149          
 150          void Timer0_Init() {
 151   1          TMOD &= 0xF0;
 152   1          TMOD |= 0x01; // T0方式1
 153   1          TH0 = (65536 - 50000) / 256; // 50ms定时
 154   1          TL0 = (65536 - 50000) % 256;
 155   1          ET0 = 1;
 156   1          TR0 = 1;
 157   1      }
 158          
 159          void Timer1_Init() {
 160   1          TMOD &= 0x0F;
 161   1          TMOD |= 0x50; // T1方式1，计数器模式
 162   1          TH1 = 0;
 163   1          TL1 = 0;
 164   1          TR1 = 1;
 165   1      }
 166          
 167          void INT0_Init() {
 168   1          IT0 = 1; // 下降沿触发
 169   1      }
 170          
 171          void UART_SendStr(char *str) {
 172   1          while(*str) {
 173   2              SBUF = *str++;
 174   2              while(!TI);
 175   2              TI = 0;
 176   2          }
 177   1      }
 178          
C51 COMPILER V9.59.0.0   MAIN                                                              07/12/2025 09:46:03 PAGE 4   

 179          void UART_ISR() interrupt 4 {
 180   1          char ch;
 181   1          char *check_pos;
 182   1          unsigned int received_checksum, calculated_checksum;
 183   1          
 184   1          if(RI) {
 185   2              ch = SBUF;
 186   2              RI = 0;
 187   2              // 接收一行，遇到回车/换行处理
 188   2              if(num_idx < sizeof(num_buf) - 1 && ch != '\r' && ch != '\n') {
 189   3                  num_buf[num_idx++] = ch;
 190   3              }
 191   2              if(ch == '\r' || ch == '\n') {
 192   3                  if(num_idx > 0) {
 193   4                      num_buf[num_idx] = '\0';
 194   4                      // 判断是否为命令行
 195   4                      if(strncmp((char*)num_buf, "CMD:", 4) == 0 && num_idx >= 5) {
 196   5                          char cmd = num_buf[4];
 197   5                          // 处理命令
 198   5                          if(cmd == 'S') collect_flag = 1;
 199   5                          if(cmd == 'E') collect_flag = 0;
 200   5                          if(cmd == 'A') {
 201   6                              current_channel = 0;
 202   6                              freq_count = 0;
 203   6                              freq_sample_flag = 0;
 204   6                              LCD_ShowString(0,0,"                ");
 205   6                              LCD_ShowString(1,0,"                ");
 206   6                          }
 207   5                          if(cmd == 'B') {
 208   6                              current_channel = 1;
 209   6                              freq_count = 0;
 210   6                              t0_count = 0;
 211   6                              freq_sample_flag = 0;
 212   6                              LCD_ShowString(0,0,"                ");
 213   6                              LCD_ShowString(1,0,"                ");
 214   6                          }
 215   5                          if(cmd == 'X'){
 216   6                              LED1 = 0;
 217   6                              UART_SendStr("TEMPER ALARM\r\n");
 218   6                          }
 219   5                          if(cmd == 'Y'){
 220   6                              LED2 = 0;
 221   6                              UART_SendStr("HUMI ALARM\r\n");
 222   6                          }
 223   5                          if(cmd == 'Z'){
 224   6                              LED3 = 0;
 225   6                              UART_SendStr("FREQ ALARM\r\n");
 226   6                          }
 227   5                          if(cmd == 'x'){
 228   6                              LED1 = 1;
 229   6                              UART_SendStr("TEMPER NORMAL\r\n");
 230   6                          }
 231   5                          if(cmd == 'y'){
 232   6                              LED2 = 1;
 233   6                              UART_SendStr("HUMI NORMAL\r\n");
 234   6                          }
 235   5                          if(cmd == 'z'){
 236   6                              LED3 = 1;
 237   6                              UART_SendStr("FREQ NORMAL\r\n");
 238   6                          }
 239   5                      } else {
 240   5                          // 不是命令，检查是否包含校验和
C51 COMPILER V9.59.0.0   MAIN                                                              07/12/2025 09:46:03 PAGE 5   

 241   5                          check_pos = strstr((char*)num_buf, " CHECKSUM:");
 242   5                          if(check_pos) {
 243   6                              // 包含校验和的数据
 244   6                              *check_pos = '\0'; // 分离数据和校验和
 245   6                              received_checksum = atoi(check_pos + 10); // 跳过" CHECKSUM:"
 246   6                              calculated_checksum = calculate_checksum((char*)num_buf);
 247   6                              
 248   6                              if(received_checksum == calculated_checksum) {
 249   7                                  // 校验和正确，处理数据
 250   7                                  UART_SendStr("[DEBUG] CHECKSUM OK\r\n");
 251   7                                  UART_SendStr("HALF VALUE: ");
 252   7                                  UART_SendStr((char*)num_buf);
 253   7                                  UART_SendStr("\r\n");
 254   7                                  if(current_channel == 0) {
 255   8                                      handle_half_value((char*)num_buf);
 256   8                                  } else if(current_channel == 1) {
 257   8                                      handle_half_freq((char*)num_buf);
 258   8                                  }
 259   7                              } else {
 260   7                                  // 校验和错误
 261   7                                  UART_SendStr("[DEBUG] CHECKSUM ERROR\r\n");
 262   7                              }
 263   6                          } else {
 264   6                              // 不包含校验和的数据（兼容旧格式）
 265   6                              UART_SendStr("HALF VALUE: ");
 266   6                              UART_SendStr((char*)num_buf);
 267   6                              UART_SendStr("\r\n");
 268   6                              if(current_channel == 0) {
 269   7                                  handle_half_value((char*)num_buf);
 270   7                              } else if(current_channel == 1) {
 271   7                                  handle_half_freq((char*)num_buf);
 272   7                              }
 273   6                          }
 274   5                      }
 275   4                      num_idx = 0;
 276   4                  }
 277   3              }
 278   2          }
 279   1      }
 280          
 281          void Timer0_ISR() interrupt 1 {
 282   1          TH0 = (65536 - 50000) / 256;
 283   1          TL0 = (65536 - 50000) % 256;
 284   1          t0_count++;
 285   1          if (t0_count >= 20) { // 20 * 50ms = 1000ms = 1s
 286   2              t0_count = 0;
 287   2              freq_sample_flag = 1; // 产生1s采样标志
 288   2          }
 289   1      }
 290          
 291          void INT0_ISR() interrupt 0 {
 292   1          freq_count++;
 293   1      }
 294          
 295          extern void Delay1000ms();
 296          sbit FREQ_IN = P3^2;
 297          
 298          void main() {
 299   1          // 简化局部变量，只保留必要的
 300   1          unsigned char temp, humi;
 301   1          char xdata buf[20]; // 放到xdata区
 302   1          unsigned int checksum; // 新增：校验和变量声明
C51 COMPILER V9.59.0.0   MAIN                                                              07/12/2025 09:46:03 PAGE 6   

 303   1      
 304   1          UART_SendStr("[DEBUG] UART_Init\r\n");
 305   1          UART_Init();
 306   1          UART_SendStr("[DEBUG] LCD_Init\r\n");
 307   1          LCD_Init();
 308   1          UART_SendStr("[DEBUG] Timer0_Init\r\n");
 309   1          Timer0_Init();
 310   1          UART_SendStr("[DEBUG] INT0_Init\r\n");
 311   1          INT0_Init();
 312   1          EA = 1; // 总中断使能
 313   1          UART_SendStr("[DEBUG] Init Done\r\n");
 314   1          LCD_ShowString(0,0,"WAIT CMD      ");
 315   1          while(1) {
 316   2              // --- 硬件状态控制器 ---
 317   2              // 根据软件状态，实时决定是否开启外部中断进行频率计数
 318   2              if (collect_flag && current_channel == 1) {
 319   3                  EX0 = 1; // 启动采集且在频率通道时，使能外部中断
 320   3              } else {
 321   3                  EX0 = 0; // 其他所有情况（停止或在温湿度通道），都关闭外部中断
 322   3              }
 323   2      
 324   2              if(collect_flag) {
 325   3                  if(current_channel == 1) { // 555频率测量 (硬件中断计数法)
 326   4                      // 轮询代码已删除，计数在后台由INT0_ISR自动完成
 327   4                      if(freq_sample_flag) {
 328   5                         
 329   5                          freq_sample_flag = 0; // 清除标志，为下个周期做准备
 330   5      
 331   5                          EA = 0; // 关总中断，保证原子操作
 332   5                          freq_value = freq_count; // 1s内的计数值就是频率
 333   5                          freq_count = 0;          // 将脉冲计数器清零，开始新的计数周期
 334   5                          EA = 1; // 开总中断
 335   5      
 336   5                          LCD_ShowString(0,0,"FREQ:       Hz");
 337   5                          LCD_ShowNum(0,6,freq_value,5);
 338   5                          // 修改：添加校验和
 339   5                          sprintf(buf, "FREQ:%u", freq_value);
 340   5                          checksum = calculate_checksum(buf);
 341   5                          sprintf(buf, "FREQ:%u CHECKSUM:%u\r\n", freq_value, checksum);
 342   5                          UART_SendStr(buf);
 343   5                      }
 344   4                  } else if(current_channel == 0) { // DHT11温湿度
 345   4                      // freq_count = 0; // 确保在DHT11模式下，频率计数器是清零的
 346   4                      if (freq_sample_flag) { // 复用1秒的定时器门控
 347   5                          
 348   5                          freq_sample_flag = 0;
 349   5                          
 350   5                          EA = 0; // 关闭总中断
 351   5                          if(DHT11_Read(&temp, &humi) == 0) {
 352   6                              EA = 1; // 恢复总中断
 353   6                              LCD_ShowString(0,0,"Temp:    C");
 354   6                              LCD_ShowString(1,0,"Humi:    %");
 355   6                              LCD_ShowNum(0,6,temp,2);
 356   6                              LCD_ShowNum(1,6,humi,2);
 357   6                              // 修改：添加校验和
 358   6                              sprintf(buf, "T:%u H:%u", (unsigned int)temp, (unsigned int)humi);
 359   6                              checksum = calculate_checksum(buf);
 360   6                              sprintf(buf, "T:%u H:%u CHECKSUM:%u\r\n", (unsigned int)temp, (unsigned int)humi, 
             -checksum);
 361   6                              UART_SendStr(buf);
 362   6                          } else {
 363   6                              EA = 1; // 恢复总中断
C51 COMPILER V9.59.0.0   MAIN                                                              07/12/2025 09:46:03 PAGE 7   

 364   6                              UART_SendStr("[DEBUG] DHT11 FAIL\r\n");
 365   6                              LCD_ShowString(0,0,"Temp:    C");
 366   6                              LCD_ShowString(1,0,"Humi:    %");
 367   6                              LCD_ShowNum(0,6,99,2);
 368   6                              LCD_ShowNum(1,6,99,2);
 369   6                              UART_SendStr("DHT11 FAIL\r\n");
 370   6                          }
 371   5                      }
 372   4                  }
 373   3              } else {
 374   3                  freq_count = 0; // 停止采集时，也清零频率计数器
 375   3                  LCD_ShowString(0,0,"WAIT CMD      ");
 376   3                  LCD_ShowString(1,0,"              ");
 377   3                  Delay1000ms();
 378   3              }
 379   2              Delay100ms(); // 新增：每次主循环末尾短暂延时，降低CPU占用
 380   2          }
 381   1      } 


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1722    ----
   CONSTANT SIZE    =    571    ----
   XDATA SIZE       =     24      44
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      8      29
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      4    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
