C51 COMPILER V9.60.7.0   MAIN                                                              07/10/2025 18:39:53 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: E:\Keil_V5\C51\BIN\C51.EXE test\test\main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Lis
                    -tings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <reg51.h>
   2          #include <stdio.h>
   3          #include "lcd1602.h"
   4          #include "dht11.h"
   5          
   6          sbit KEY = P3^2; // 启动/停止按键
   7          
   8          bit collect_flag = 0; // 采集标志
   9          volatile char last_rx = 0;
  10          volatile bit rx_flag = 0;
  11          // char debug[17]; // 全局变量（删除，调试用局部变量）
  12          
  13          // 优化：用于接收上位机回发的数字，缩短为6字节
  14          char num_buf[6]; // 最多存储"99 99\0"
  15          unsigned char num_idx = 0;
  16          
  17          volatile unsigned char current_channel = 0; // 0=DHT11, 1=555频率
  18          volatile bit freq_sample_flag = 0;
  19          volatile unsigned char t0_count = 0;
  20          
  21          // -- 频率测量所需的状态变量 --
  22          volatile unsigned int freq_count = 0; // 用于累加脉冲数量
  23          unsigned int freq_value = 0;        // 用于存放最终计算出的频率值
  24          static bit last_p32_state = 1;      // 用于检测P3.2引脚的下降沿
  25          
  26          void UART_Init() {
  27   1          SCON = 0x50;      // 8位数据,可变波特率
  28   1          TMOD |= 0x20;     // 定时器1，8位自动重装
  29   1          TH1 = 0xFD;       // 9600波特率
  30   1          TL1 = 0xFD;
  31   1          TR1 = 1;
  32   1          ES = 1;
  33   1          EA = 1;
  34   1      }
  35          
  36          void Timer0_Init() {
  37   1          TMOD &= 0xF0;
  38   1          TMOD |= 0x01; // T0方式1
  39   1          TH0 = (65536 - 50000) / 256; // 50ms定时
  40   1          TL0 = (65536 - 50000) % 256;
  41   1          ET0 = 1;
  42   1          TR0 = 1;
  43   1      }
  44          
  45          void Timer1_Init() {
  46   1          TMOD &= 0x0F;
  47   1          TMOD |= 0x50; // T1方式1，计数器模式
  48   1          TH1 = 0;
  49   1          TL1 = 0;
  50   1          TR1 = 1;
  51   1      }
  52          
  53          void INT0_Init() {
  54   1          IT0 = 1; // 下降沿触发
C51 COMPILER V9.60.7.0   MAIN                                                              07/10/2025 18:39:53 PAGE 2   

  55   1      }
  56          
  57          void UART_SendStr(char *str) {
  58   1          while(*str) {
  59   2              SBUF = *str++;
  60   2              while(!TI);
  61   2              TI = 0;
  62   2          }
  63   1      }
  64          
  65          void UART_ISR() interrupt 4 {
  66   1          if(RI) {
  67   2              char ch = SBUF;
  68   2              RI = 0;
  69   2              // 判断是否为数字、空格或回车
  70   2              if((ch >= '0' && ch <= '9') || ch == ' '){
  71   3                  if(num_idx < sizeof(num_buf) - 1) {
  72   4                      num_buf[num_idx++] = ch;
  73   4                  }
  74   3              } else if(ch == '\r' || ch == '\n') {
  75   3                  if(num_idx > 0) {
  76   4                      num_buf[num_idx] = '\0';
  77   4                      UART_SendStr("HALF VALUE: "); // 保留调试信息
  78   4                      UART_SendStr(num_buf);
  79   4                      UART_SendStr("\r\n");
  80   4                      num_idx = 0;
  81   4                  }
  82   3              } else {
  83   3                  // 其他命令处理
  84   3                  last_rx = ch;
  85   3                  rx_flag = 1;
  86   3                  if(last_rx == 'S') collect_flag = 1;
  87   3                  if(last_rx == 'E') collect_flag = 0;
  88   3                  if(last_rx == 'A') {
  89   4                      current_channel = 0;
  90   4                      freq_count = 0;
  91   4                      freq_sample_flag = 0;
  92   4                      LCD_ShowString(0,0,"                ");
  93   4                      LCD_ShowString(1,0,"                ");
  94   4                  }
  95   3                  if(last_rx == 'B') {
  96   4                      current_channel = 1;
  97   4                      freq_count = 0;
  98   4                      t0_count = 0;
  99   4                      freq_sample_flag = 0;
 100   4                      LCD_ShowString(0,0,"                ");
 101   4                      LCD_ShowString(1,0,"                ");
 102   4                  }
 103   3              }
 104   2          }
 105   1      }
 106          
 107          void Timer0_ISR() interrupt 1 {
 108   1          TH0 = (65536 - 50000) / 256;
 109   1          TL0 = (65536 - 50000) % 256;
 110   1          t0_count++;
 111   1          if (t0_count >= 20) { // 20 * 50ms = 1000ms = 1s
 112   2              t0_count = 0;
 113   2              freq_sample_flag = 1; // 产生1s采样标志
 114   2          }
 115   1      }
 116          
C51 COMPILER V9.60.7.0   MAIN                                                              07/10/2025 18:39:53 PAGE 3   

 117          void INT0_ISR() interrupt 0 {
 118   1          freq_count++;
 119   1      }
 120          
 121          extern void Delay1000ms();
 122          sbit FREQ_IN = P3^2;
 123          
 124          void main() {
 125   1          // 简化局部变量，只保留必要的
 126   1          unsigned char temp, humi;
 127   1          char buf[20];
 128   1      
 129   1          UART_SendStr("[DEBUG] UART_Init\r\n");
 130   1          UART_Init();
 131   1          UART_SendStr("[DEBUG] LCD_Init\r\n");
 132   1          LCD_Init();
 133   1          UART_SendStr("[DEBUG] Timer0_Init\r\n");
 134   1          Timer0_Init();
 135   1          UART_SendStr("[DEBUG] INT0_Init\r\n");
 136   1          INT0_Init();
 137   1          EA = 1; // 总中断使能
 138   1          UART_SendStr("[DEBUG] Init Done\r\n");
 139   1          LCD_ShowString(0,0,"WAIT CMD      ");
 140   1          while(1) {
 141   2              // --- 硬件状态控制器 ---
 142   2              // 根据软件状态，实时决定是否开启外部中断进行频率计数
 143   2              if (collect_flag && current_channel == 1) {
 144   3                  EX0 = 1; // 启动采集且在频率通道时，使能外部中断
 145   3              } else {
 146   3                  EX0 = 0; // 其他所有情况（停止或在温湿度通道），都关闭外部中断
 147   3              }
 148   2      
 149   2              if(collect_flag) {
 150   3                  if(current_channel == 1) { // 555频率测量 (硬件中断计数法)
 151   4                      // 轮询代码已删除，计数在后台由INT0_ISR自动完成
 152   4                      if(freq_sample_flag) {
 153   5                          freq_sample_flag = 0; // 清除标志，为下个周期做准备
 154   5      
 155   5                          EA = 0; // 关总中断，保证原子操作
 156   5                          freq_value = freq_count; // 1s内的计数值就是频率
 157   5                          freq_count = 0;          // 将脉冲计数器清零，开始新的计数周期
 158   5                          EA = 1; // 开总中断
 159   5      
 160   5                          LCD_ShowString(0,0,"FREQ:       Hz");
 161   5                          LCD_ShowNum(0,6,freq_value,5);
 162   5                          sprintf(buf, "FREQ:%u\r\n", freq_value);
 163   5                          UART_SendStr(buf);
 164   5                      }
 165   4                  } else if(current_channel == 0) { // DHT11温湿度
 166   4                      // freq_count = 0; // 确保在DHT11模式下，频率计数器是清零的
 167   4                      if (freq_sample_flag) { // 复用1秒的定时器门控
 168   5                          freq_sample_flag = 0;
 169   5                          
 170   5                          EA = 0; // 关闭总中断
 171   5                          if(DHT11_Read(&temp, &humi) == 0) {
 172   6                              EA = 1; // 恢复总中断
 173   6                              LCD_ShowString(0,0,"Temp:    C");
 174   6                              LCD_ShowString(1,0,"Humi:    %");
 175   6                              LCD_ShowNum(0,6,temp,2);
 176   6                              LCD_ShowNum(1,6,humi,2);
 177   6                              sprintf(buf, "T:%u H:%u\r\n", (unsigned int)temp, (unsigned int)humi);
 178   6                              UART_SendStr(buf);
C51 COMPILER V9.60.7.0   MAIN                                                              07/10/2025 18:39:53 PAGE 4   

 179   6                          } else {
 180   6                              EA = 1; // 恢复总中断
 181   6                              UART_SendStr("[DEBUG] DHT11 FAIL\r\n");
 182   6                              LCD_ShowString(0,0,"Temp:    C");
 183   6                              LCD_ShowString(1,0,"Humi:    %");
 184   6                              LCD_ShowNum(0,6,99,2);
 185   6                              LCD_ShowNum(1,6,99,2);
 186   6                              UART_SendStr("DHT11 FAIL\r\n");
 187   6                          }
 188   5                      }
 189   4                  }
 190   3              } else {
 191   3                  freq_count = 0; // 停止采集时，也清零频率计数器
 192   3                  LCD_ShowString(0,0,"WAIT CMD      ");
 193   3                  LCD_ShowString(1,0,"              ");
 194   3                  Delay1000ms();
 195   3              }
 196   2          }
 197   1      } 


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    799    ----
   CONSTANT SIZE    =    257    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     14      26
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      4    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
